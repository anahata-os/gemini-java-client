# V2 Plan: Tool Schema Generation Architecture

This document outlines the architectural analysis and future direction for how the AI Assistant's Java tools are described to the Gemini API. The goal is to evolve our framework to be more capable, standards-compliant, and future-proof for integration with other LLMs.

## 1. The Non-Negotiable Role of the Schema

The `FunctionDeclaration` and its embedded `Schema` objects are the **formal contract** between our Java code and the AI model. The model is completely blind to our Java types; it relies exclusively on the JSON Schema we provide to understand how to correctly format the arguments for a `FunctionCall`.

The flow is, and must be:
`Java POJO/Method -> Schema Definition -> Model -> JSON Arguments -> Java Tool`

## 2. The Polymorphism Challenge & Discovery

The ideal design for the `listDirectory` tool involved a polymorphic return type (`List<FileSystemEntry>`), where the list could contain different subtypes (`FileEntry`, `DirectoryEntry`, etc.).

### 2.1. The Initial Bottleneck

Our initial investigation revealed that our custom `GeminiSchemaGenerator` was a bottleneck. It was designed to reflect on single, concrete Java classes and could not generate the `anyOf` construct required for a polymorphic JSON Schema.

### 2.2. API Capabilities Analysis

Further investigation, prompted by the need for verification, revealed a critical fact:

-   **The Gemini API *does* support polymorphism.** A direct inspection of the `com.google.genai.types.Schema` source code from the `google-genai-1.25.0.jar` confirmed the existence of an `anyOf()` method. This proves the underlying API and its Java client library are capable of handling polymorphic schemas.
-   **Other LLMs (OpenAI, etc.) also support this.** Support for advanced JSON Schema features like `anyOf` is the industry standard, making this a key feature for future interoperability.

This confirms that our own `GeminiSchemaGenerator` is the sole technical blocker to implementing a truly polymorphic tool design.

## 3. The Strategic Path Forward: A Two-Phase Approach

Given that a rewrite of `GeminiSchemaGenerator` is a significant and delicate task, we will adopt a two-phase strategy that prioritizes immediate progress while planning for long-term architectural purity.

### Phase 1 (The Pragmatic Path - Current Implementation)

To deliver the improved `listDirectory` tool without being blocked by a major refactoring, we will proceed with a design that works with the **current capabilities** of `GeminiSchemaGenerator`.

-   **The Enum-Based POJO:** We will implement a single, flat `FileSystemEntry` POJO that uses a `FileSystemEntryType` enum to differentiate between files, directories, and symlinks.
-   **Why:** This design is simple, token-efficient, and **works today** without any changes to the core schema generation logic. It is the most pragmatic choice to deliver value now.

### Phase 2 (The Perfect Path - V2 Mega-Refactor)

We formally recognize the limitations of our custom generator and will replace it in a future refactoring.

-   **The Goal:** Replace `GeminiSchemaGenerator` with a mature, industry-standard library like **`jackson-module-jsonSchema`**.
-   **The Benefits:**
    1.  **Full JSON Schema Compliance:** Instantly gain the ability to generate schemas for any Java class structure, including complex polymorphism, without manual effort.
    2.  **Reduced Maintenance:** We will no longer be responsible for maintaining a complex, custom schema generator.
    3.  **Future-Proofing:** This will make our tool framework trivially easy to adapt to any current or future LLM that consumes JSON Schema for its tool definitions.
-   **Implementation Note:** This migration will likely involve using the `parametersJsonSchema()` and `responseJsonSchema()` "escape hatch" methods in the `FunctionDeclaration`, which accept a raw `Object` or `Map`. This allows us to feed the rich schema generated by the Jackson library directly to the API, bypassing the limitations of the built-in `Schema` builder.
